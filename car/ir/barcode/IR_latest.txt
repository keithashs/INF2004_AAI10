#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "pico/stdlib.h"
#include "hardware/adc.h"
#include "hardware/gpio.h"

// Pin assignments.
#define IR_ADC_GPIO        26    // Analog output to GP26 (ADC0).
#define IR_ADC_CHANNEL      0
#define IR_DIGITAL_GPIO    27    // Digital output to GP27.

// Analog sampling.
#define ADC_OVERSAMPLES    16    // Number of quick ADC reads averaged per sample
#define ADC_SAMPLE_MS      20    // Interval for sampling and printing (ms).

// Digital glitch filter.
#define MIN_EDGE_US        9000   // Ignore edges shorter than this (us). Increased for noise during slow scans.

// Barcode parameters.
#define MAX_WIDTHS         200   // Maximum number of pulse widths in buffer.
#define SCAN_TIMEOUT_MS    5000  // Timeout (ms) after last edge to process barcode. Increased for slow scans.
#define LONG_WIDTH_US      2000000 // Threshold for long leading/trailing space (2 seconds).
#define MIN_VALID_WIDTH_US 100  // Minimum valid width to filter ultra-short noise.
#define THRESHOLD_MULTIPLIER 2.0  // Multiplier for unit (midpoint for 3:1 ratio: (3+1)/2=2.0).

// ISR-shared state (volatile).
static volatile uint64_t last_edge_us = 0; // Timestamp (us) of the previous digital edge.
static volatile bool     last_level   = 0; // Logic state before the current edge.
static volatile uint32_t widths[MAX_WIDTHS]; // Pulse widths (lower 31 bits us, bit 31: 1=high/bar, 0=low/space).
static volatile int      num_widths   = 0; // Number of stored widths.

// Current time in us.
static inline uint64_t micros_now(void) {
    return to_us_since_boot(get_absolute_time());
}

// Current time in ms.
static inline uint32_t millis_now(void) {
    return (uint32_t)(micros_now() / 1000);
}

// Comparator for qsort on uint32_t.
static int uint32_cmp(const void *a, const void *b) {
    uint32_t va = *(const uint32_t *)a;
    uint32_t vb = *(const uint32_t *)b;
    return (va > vb) - (va < vb);
}

// GPIO IRQ handler.
static void ir_d0_isr(uint gpio, uint32_t events) {
    if (gpio != IR_DIGITAL_GPIO) return;
    uint64_t t_now = micros_now();

    bool level_now = gpio_get(IR_DIGITAL_GPIO);

    if (last_edge_us != 0) {
        uint32_t dt = (uint32_t)(t_now - last_edge_us);
        if (dt >= MIN_EDGE_US && dt < 5000000 && num_widths < MAX_WIDTHS) {
            uint32_t entry = dt | (last_level ? 0x80000000U : 0);  // Bars when GPIO high
            widths[num_widths++] = entry;
        }
    }

    last_edge_us = t_now;
    last_level = level_now;
}

// Get digit from two wide bar positions (1-based: b1=1, ..., b5=5).
static int get_bar_digit(int bar_pos1, int bar_pos2) {
    if (bar_pos1 > bar_pos2) { int temp = bar_pos1; bar_pos1 = bar_pos2; bar_pos2 = temp; }
    if (bar_pos1 == 1 && bar_pos2 == 2) return 1;
    if (bar_pos1 == 1 && bar_pos2 == 3) return 2;
    if (bar_pos1 == 2 && bar_pos2 == 3) return 3;
    if (bar_pos1 == 1 && bar_pos2 == 4) return 4;
    if (bar_pos1 == 2 && bar_pos2 == 4) return 5;
    if (bar_pos1 == 1 && bar_pos2 == 5) return 6;
    if (bar_pos1 == 2 && bar_pos2 == 5) return 7;
    if (bar_pos1 == 3 && bar_pos2 == 5) return 8;
    if (bar_pos1 == 3 && bar_pos2 == 4) return 9;
    if (bar_pos1 == 4 && bar_pos2 == 5) return 0;
    return -1; // Invalid
}

// Decode a single character from 9 binary elements (1=wide, 0=narrow).
static char decode_char(const int binary[9]) {
    int b1 = binary[0], s1 = binary[1], b2 = binary[2], s2 = binary[3],
        b3 = binary[4], s3 = binary[5], b4 = binary[6], s4 = binary[7],
        b5 = binary[8];

    int num_wide = b1 + s1 + b2 + s2 + b3 + s3 + b4 + s4 + b5;
    if (num_wide != 3) return '?';

    int wide_bars = b1 + b2 + b3 + b4 + b5;
    int wide_spaces = s1 + s2 + s3 + s4;

    if (wide_bars == 0 && wide_spaces == 3) {
        // Special characters (-, ., space, *).
        int narrow_space_pos = 0;
        if (!s1) narrow_space_pos = 1;
        else if (!s2) narrow_space_pos = 2;
        else if (!s3) narrow_space_pos = 3;
        else if (!s4) narrow_space_pos = 4;

        switch (narrow_space_pos) {
            case 1: return '-';
            case 2: return '.';
            case 3: return ' ';
            case 4: return '*';
            default: return '?';
        }
    } else if (wide_bars == 2 && wide_spaces == 1) {
        // Normal characters (digits, letters).
        // Find wide bar positions (1-based).
        int bar_pos[2] = {0, 0};
        int count = 0;
        if (b1) bar_pos[count++] = 1;
        if (b2) bar_pos[count++] = 2;
        if (b3) bar_pos[count++] = 3;
        if (b4) bar_pos[count++] = 4;
        if (b5) bar_pos[count++] = 5;
        if (count != 2) return '?';

        int digit = get_bar_digit(bar_pos[0], bar_pos[1]);
        if (digit == -1) return '?';

        // Find wide space position (1-based).
        int wide_space_pos = 0;
        if (s1) wide_space_pos = 1;
        else if (s2) wide_space_pos = 2;
        else if (s3) wide_space_pos = 3;
        else if (s4) wide_space_pos = 4;
        if (wide_space_pos == 0) return '?';

        int base = (wide_space_pos - 1) * 10;
        int value = base + digit;
        if (value < 10) {
            return '0' + value;
        } else if (value <= 35) {
            return 'A' + (value - 10);
        } else {
            return '?';
        }
    }
    return '?';
}

// Reverse map for reversed patterns
static char reverse_map(char c) {
    switch (c) {
        case 'V': return '0';
        case 'U': return '1';
        case 'Z': return '5';
        case 'Y': return '7';
        case 'W': return '8';
        case 'X': return '9';
        case 'L': return 'A';
        case 'K': return 'B';
        case 'S': return 'C';
        case 'T': return 'D';
        case 'R': return 'E';
        case 'P': return 'F';
        case 'Q': return 'G';
        case 'O': return 'H';
        case 'M': return 'I';
        case 'N': return 'J';
        case 'B': return 'K';
        case 'A': return 'L';
        case 'I': return 'M';
        case 'J': return 'N';
        case 'H': return 'O';
        case 'F': return 'P';
        case 'G': return 'Q';
        case 'E': return 'R';
        case 'C': return 'S';
        case 'D': return 'T';
        case '1': return 'U';
        case '0': return 'V';
        case '8': return 'W';
        case '9': return 'X';
        case '7': return 'Y';
        case '5': return 'Z';
        case '*': return '-';
        case ' ': return '.';
        case '-': return '*';
        case '.': return ' ';
        default: return '?';
    }
}

// Function to reverse a string in place
static void str_reverse(char *str) {
    int len = strlen(str);
    for (int i = 0; i < len / 2; i++) {
        char temp = str[i];
        str[i] = str[len - 1 - i];
        str[len - 1 - i] = temp;
    }
}

// Decode a single character using local thresholds for its own widths.
static char decode_local(const uint32_t *widths) {
    // Check structure: bar, space, bar, space, ..., bar
    for (int j = 0; j < 9; j++) {
        bool expected_bar = (j % 2 == 0);
        bool is_bar = (widths[j] & 0x80000000U) != 0;
        if (is_bar != expected_bar) {
            return '?';
        }
    }

    // Calculate total sum of widths
    double total = 0.0;
    for (int j = 0; j < 9; j++) {
        uint32_t dt = widths[j] & 0x7FFFFFFFU;
        total += dt;
    }
    double unit = total / 15.0;
    double th = unit * THRESHOLD_MULTIPLIER;

    // Compute binary
    int binary[9];
    for (int j = 0; j < 9; j++) {
        uint32_t dt = widths[j] & 0x7FFFFFFFU;
        binary[j] = (dt > th) ? 1 : 0;
    }

    return decode_char(binary);
}

// Decode the barcode sequence.
static void decode_and_print(void) {
    if (num_widths < 9) {
        printf("Scan too short: %d widths\n", num_widths);
        return;
    }

    // Copy buffer to local (non-volatile).
    uint32_t local_widths[MAX_WIDTHS];
    memcpy(local_widths, (const void*)widths, num_widths * sizeof(uint32_t));

    // Filter out ultra-short widths (noise).
    int filtered_num = 0;
    for (int i = 0; i < num_widths; i++) {
        uint32_t dt_us = local_widths[i] & 0x7FFFFFFFU;
        if (dt_us >= MIN_VALID_WIDTH_US) {
            local_widths[filtered_num++] = local_widths[i];
        } else {
            printf("Filtered noise width: %u us at index %d\n", dt_us, i);
        }
    }
    if (filtered_num < 9) {
        printf("After filtering, too short: %d widths\n", filtered_num);
        return;
    }

    // Force trim leading space if present (quiet zone).
    int start_idx = 0;
    if (filtered_num > 0 && !(local_widths[0] & 0x80000000U)) {
        start_idx = 1;
        printf("Trimmed leading space (force).\n");
    }

    // Force trim trailing space if present (quiet zone).
    int end_idx = filtered_num;
    if (end_idx > start_idx && !(local_widths[end_idx-1] & 0x80000000U)) {
        end_idx--;
        printf("Trimmed trailing space (force).\n");
    }

    int trimmed_num = end_idx - start_idx;
    if (trimmed_num < 9) {
        printf("After trim, too short: %d widths\n", trimmed_num);
        return;
    }

    // Print raw widths for debugging (filtered and trimmed).
    printf("Raw widths (%d filtered/trimmed):\n", trimmed_num);
    for (int i = start_idx; i < end_idx; i++) {
        bool is_bar = (local_widths[i] & 0x80000000U) != 0;
        uint32_t dt_us = local_widths[i] & 0x7FFFFFFFU;
        printf("%s%u ", is_bar ? "B" : "S", dt_us);
    }
    printf("\n");

    // Attempt to decode forward with local thresholds per character
    printf("Decoding characters:\n");
    char result[100] = {0};
    int res_idx = 0;
    int i = start_idx;
    bool is_start = true;
    while (i + 8 < end_idx) {
        char c = decode_local(&local_widths[i]);
        // Print binary for logging
        int binary[9];
        double total = 0.0;
        for (int j = 0; j < 9; j++) {
            uint32_t dt = local_widths[i + j] & 0x7FFFFFFFU;
            total += dt;
        }
        double unit = total / 15.0;
        double th = unit * THRESHOLD_MULTIPLIER;
        printf("Char at pos %d: unit=%.1f th=%.1f (total=%.1f)\n", i - start_idx, unit, th, total);
        for (int j = 0; j < 9; j++) {
            uint32_t dt = local_widths[i + j] & 0x7FFFFFFFU;
            binary[j] = (dt > th) ? 1 : 0;
        }
        printf("Pos %d: ", i - start_idx);
        for (int j = 0; j < 9; j++) {
            printf("%d", binary[j]);
        }
        printf(" -> ");
        printf("%c\n", c);
        if (c == '?') {
            printf("Failed to decode character at position %d\n", i - start_idx);
            break;
        }
        result[res_idx++] = c;
        if (is_start && c != '*') {
            printf("First character not start *\n");
            break;
        }
        is_start = false;
        i += 9;
        if (i >= end_idx) break;
        // Check inter-character is space (low)
        if ((local_widths[i] & 0x80000000U) != 0) {
            printf("Inter character not space at %d\n", i - start_idx);
            break;
        }
        i += 1;
    }

    bool valid = (i == end_idx && res_idx > 1 && result[0] == '*' && result[res_idx - 1] == '*');
    if (valid) {
        result[res_idx - 1] = 0; // Remove stop *
        printf("\nDecoded barcode: %s\n", result + 1); // Skip start *
        return;
    }

    // If forward fails, try reverse
    printf("\nTrying reverse scan...\n");
    int length = end_idx - start_idx;
    for (int j = 0; j < length / 2; j++) {
        uint32_t temp = local_widths[start_idx + j];
        local_widths[start_idx + j] = local_widths[end_idx - 1 - j];
        local_widths[end_idx - 1 - j] = temp;
    }
    // No flip

    // Re-trim leading space if present
    if (length > 0 && !(local_widths[start_idx] & 0x80000000U)) {
        start_idx++;
        length--;
    }
    // Re-trim trailing space if present
    if (length > 0 && !(local_widths[start_idx + length - 1] & 0x80000000U)) {
        length--;
    }
    end_idx = start_idx + length;
    trimmed_num = length;
    if (trimmed_num < 9) {
        printf("After reverse trim, too short: %d widths\n", trimmed_num);
        return;
    }

    // Print reversed widths
    printf("Reversed widths (%d):\n", trimmed_num);
    for (int k = start_idx; k < end_idx; k++) {
        bool is_bar = (local_widths[k] & 0x80000000U) != 0;
        uint32_t dt_us = local_widths[k] & 0x7FFFFFFFU;
        printf("%s%u ", is_bar ? "B" : "S", dt_us);
    }
    printf("\n");

    // Decode reversed with local thresholds
    printf("Decoding reversed characters:\n");
    memset(result, 0, sizeof(result));
    res_idx = 0;
    i = start_idx;
    is_start = true;
    while (i + 8 < end_idx) {
        char c = decode_local(&local_widths[i]);
        // Print binary for logging
        int binary[9];
        double total = 0.0;
        for (int j = 0; j < 9; j++) {
            uint32_t dt = local_widths[i + j] & 0x7FFFFFFFU;
            total += dt;
        }
        double unit = total / 15.0;
        double th = unit * THRESHOLD_MULTIPLIER;
        printf("Reversed char at pos %d: unit=%.1f th=%.1f (total=%.1f)\n", i - start_idx, unit, th, total);
        for (int j = 0; j < 9; j++) {
            uint32_t dt = local_widths[i + j] & 0x7FFFFFFFU;
            binary[j] = (dt > th) ? 1 : 0;
        }
        printf("Pos %d: ", i - start_idx);
        for (int j = 0; j < 9; j++) {
            printf("%d", binary[j]);
        }
        printf(" -> ");
        printf("%c\n", c);
        if (c == '?') {
            printf("Failed to decode reversed character at position %d\n", i - start_idx);
            break;
        }
        result[res_idx++] = c;
        if (is_start && c != '-') {
            printf("First reversed character not start -\n");
            break;
        }
        is_start = false;
        i += 9;
        if (i >= end_idx) break;
        // Inter character is space
        if ((local_widths[i] & 0x80000000U) != 0) {
            printf("Inter character not space in reversed at %d\n", i - start_idx);
            break;
        }
        i += 1;
    }

    valid = (i == end_idx && res_idx > 1 && result[0] == '-' && result[res_idx - 1] == '-');
    if (valid) {
        char data[100];
        strcpy(data, result + 1);
        data[res_idx - 2] = '\0'; // Remove stop -
        for (int k = 0; k < strlen(data); k++) {
            data[k] = reverse_map(data[k]);
        }
        str_reverse(data);
        printf("\nDecoded barcode (reversed): %s\n", data);
    } else {
        printf("\nNo valid barcode decoded.\n");
    }
}

int main(void) {
    stdio_init_all();
    sleep_ms(1500);

    adc_init();
    adc_gpio_init(IR_ADC_GPIO);
    adc_select_input(IR_ADC_CHANNEL);

    gpio_init(IR_DIGITAL_GPIO);
    gpio_set_dir(IR_DIGITAL_GPIO, GPIO_IN);
    gpio_pull_up(IR_DIGITAL_GPIO);

    gpio_set_irq_enabled_with_callback(
        IR_DIGITAL_GPIO,
        GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL,
        true,
        &ir_d0_isr
    );

    uint16_t threshold_raw = 2200; // Raised to avoid false triggers near 2000.

    uint32_t last_print_ms = millis_now();

    while (true) {
        uint32_t acc = 0;
        for (int i = 0; i < ADC_OVERSAMPLES; i++) {
            acc += adc_read();
            sleep_us(10);
        }
        uint16_t raw = acc / ADC_OVERSAMPLES;

        bool is_black = (raw > threshold_raw);

        uint32_t now = millis_now();
        if (now - last_print_ms >= ADC_SAMPLE_MS) {
            last_print_ms = now;

            printf(
                "ADC raw=%u surface=%s || Stored widths=%d\n",
                raw, is_black ? "BLACK" : "WHITE",
                num_widths
            );
        }

        // Check for barcode scan completion.
        if (num_widths > 0 && (now - (uint32_t)(last_edge_us / 1000) >= SCAN_TIMEOUT_MS)) {
            decode_and_print();
            num_widths = 0;
        }
    }
}